# 180623

## 플랫폼 디바이스
* SoC 내부에 임베디드된 디바이스 또는 버스 디바이스로 CPU로부터 직접 주소 지정이 가능
* 디바이스의 시작(probe)지점이 정해지지 않은 디바이스 -> 누군가가 지정해줘야 하는 디바이스
* 플로그 가능한 PCI, USB 버스에 연결되는 디바이스는 플랫폼 디바이스가 아니다.
* 버스를 타지 않는 플랫폼 디바이스는 CPU가 직접 컨트롤한다. (레지스터도 갖는다.)

## 실습
* 참고 링크
    * <https://github.com/jeyaramvrp/kernel-module-programming/tree/master/sample-platform-driver>
    * <https://www.codeproject.com/Tips/1080177/Linux-Platform-Device-Driver>
* /sys/bus/platform/devices(or drivers) 에서 생겼는지 확인
* http://jake.dothome.co.kr/device-driver-3/
* device drvier attribute
* http://jake.dothome.co.kr/gpio-1

# 180630

* 핀 컨트롤
    * <http://jake.dothome.co.kr/pinctrl/>

* 전기
    * 최소/최대 전압, 전류. 중간 전압을 걸면 타버림. 전류를 약하게 하면 불빛이 약하고 높으면 불빛이 강하고 대신 수명이 짧아짐.
    * 전압이 높은 것에서 낮은곳으로 전위차에의해 전류가 흐른다. 전자의 흐름은 반대
    * 반도체?? 전류 증폭?? - 인풋이 두개 101총통과 가능 1을 흘려서 100이 통과 가능하도록
    * 60W - 백열전구, 5, 10, 30, 60, 100 뜨거워짐
    * 라즈베리파이 2 - 5W 1A, 5V 뜨겁긴한데 잡을 수 있을정도 ㅎ...
    * 전력 = 열
    * 효율 - 인풋 100, 10은 열로, 90은 전기로 날라감 - 효율 90
    * 직렬에 나뉜 저항에는 전압은 나눠서 걸림 흐르는 전류는 일정
    * 정전기 몇만 볼트, 살고 죽는건 저항의 문제
    * 직류는 충격이 없는데, 교류는 왔다 갔다 하는 충격이 옴.

* GPIO에 얼마나 열이 날까
    * Gpio 하나에 10ma 흘려 거기 led가 100개 달려 총 1a흘러 (병렬?)
    * 핀 컨트롤은 gpio에서 시작 노는 핀이 많아서?
    * MOS-FET, 트랜지스터 둘 중 하나로 만들 수 있음. 트랜지스터 하나에 전압강하가 일어남(저항이 아닌데) (증폭기)), 트랜지스터는 전류 증폭, MOSFETS은 전압을 걸면 뚫림
        * Base, colloctor, Emitor ?
        * open collector?? - 트랜지스터가 열렸다
    * General Purpose IO - 디지털 데이터를 주고 받을 떄, 뭔지 모르지만 0과1로 데이터를 전달할 떄, 
    * 인풋 모드 - 1,0 입력. 출력 모드 - 1, 0 출력
    * GPIO 장치에서 전력이 들어오는 경우 단가를 줄이기 위해 이것저것 붙이다 보면 타버림

* 회로
    * 삼각형 전류 증폭기?
    * 역전압 - 거꾸로 올라감 (- to +), 보호회로 해석할 필요 없음
    * pad - pinball 
    * pull up/down (단가를 줄이는 수단??)

* 히언 - 입베디드 레시피 HW 기초 지식
* 스위치 포트 8개씩 3개를 달아서 24포트를 만드는 거임 한번에 하면 너무 뜨거워짐

# 180707

* pinctrl 
    * <http://jake.dothome.co.kr/pinctrl/>
    * <http://jake.dothome.co.kr/pinctrl-2/>

* 핀 컨트롤 번호랑 gpio 번호랑 다름... (핀 컨트롤 번호가 더 많음? gpio가 핀컨트롤에 포함?)

* uart rts/cts 하드웨어적으로 플로우 컨트롤 (단가 줄이려면 빼기 )

* 핀을 공유하는 경우에만 핀컨트롤 필요. 하나만 존재하면 핀 컨트롤할 필요가 없음

* grps - uart, nor를 쓰기 위해서는 그룹들이 다 필요하고 gpio는 별도로 사용가능...
    * uart1 grps 3개가 있는데 그 중 한핀을 다른 기능이 이용하면 uart1 기능은 사용 불가

* pinconf 는 칩마다 지원하는 함수가 다름...

* 원래 pinmux - pinconf 매핑이 수동이었는데 이제 디바이스 트리로 함.

* pinconf는 핀마다 설정 pinmux는 여러 기능들이 핀을 공유하는 경우 사용?

```c
static struct pinctrl_map mapping[] __initdata = {
    PIN_MAP_MUX_GROUP("foo-i2c.0", PINCTRL_STATE_DEFAULT, "pinctrl-foo", "i2c0", "i2c0"), // GROUP에다가 MUX로
    PIN_MAP_CONFIGS_GROUP("foo-i2c.0", PINCTRL_STATE_DEFAULT, "pinctrl-foo", "i2c0", i2c_grp_configs), // GROUP에 설정
    PIN_MAP_CONFIGS_PIN("foo-i2c.0", PINCTRL_STATE_DEFAULT, "pinctrl-foo", "i2c0scl", i2c_pin_configs), // PIN에 설정
    PIN_MAP_CONFIGS_PIN("foo-i2c.0", PINCTRL_STATE_DEFAULT, "pinctrl-foo", "i2c0sda", i2c_pin_configs), // PIN에 설정
};
```

* 멀티 스테이트에서는 보통 저전력 소모를 위해 default state, sleep state를 사용
* 싱글 스테이트에는 default만...
* Device tree에서 &을 앞에 붙이면 노드명을 의미...?

* generic client - consumer
    * pinctrl-0 ~ pinctrl-N 속성
        * pinctrl1-0 = <> 더미 매핑

* drivers/pinctrl/pinctrl-bcm2835.c
    * 디바이스 트리를 보니 compatible하면 probe() 호출

* 플랫폼 드라이버 프로브할 때, 하는 일? -> 메모리 할당, driver irq 등록, iomem(reg 영역), ioremap (매핑))
    * 추가로 서브시스템들을 레지스터함.
    * 추가로 기타 설정(디폴트 설정 등) 기본적인 하드웨어 설정

## 실습

* pinctrl-bcm2835.c, pinctrl-ms2-mux.c (lsk-4.14/pinctrl/bcm)

* 문제
    * device tree에 pinctrl 노드 추가
    * 드라이브의 프로브에서 pinctrl register를 하는데 ops 구조체
        * pin 0, 1, 2, 3 - gpio, nand, uart
        * pin 4, 5 - nand, uart
        * pin 6, 7 - nand, uart, i2c

* dtb, dtc, dts ??? device tree.... 
```
apt install device-tree-compiler
```
* dtb 수정 필요

# 180721

## gpio
* http://jake.dothome.co.kr/gpio-1/
* 핀 컨트롤에도 gpio로 쓸 수 있고, gpio 전용 칩을 달면 걔는 핀 컨트롤이랑 관계없음 gpio 전용임
    * gpio 수는 솔루션마다 필요한 수가 다름
    * 많이 필요한 경우에는 x, y로 해서 8, 8 64개를 만들어 쓸 수 있기도 하고 칩을 그냥 사기도 함.
* gpio, sysfs로 쓰면 불편했음 그래서 회사들은 character 장치를 만들어서 이용했음. 이거 통일 시미

* sysfs를 써서 하면 하이라키 형태로 되어 있어 gpio를 이용하기 까다로웠음. usb나 pci같은 경우에는 sysfs가 더 편하기도 함. (구현이... 불편...)

* PIO ? 주변 입출력
* Edge detect - 전기 신호로 인터럽트를 줄 때, 업으로 가던 다운으로 가던 그때마다 인터럽트 발생. Level detect - 쭈욱 인터럽트가 발생
    * level detect로 해놨는데 인터럽트 올 때마다 print 해놨으면 계소오옥 프린트함.

* rspi2 회로도 in-out으로 구분.ㄴ
* 출력 모드에서 아래 3개중에서 설정해서 사용
    * push-pull 
    * open-drain
    * open-source 

## GPIO pin 블록다이어 그램 회로
* 입력 전류에 대해 반응하는 트랜지스터 소자
    * 주로 Base, Collector, Emitter 세 개의 핀을 사용
    * 옛날 시스템

* 입력 전압에 대해 반응하는 전계효과 트랜지스터(FET: Field Effect Transistor) 소자
    * 주로 Gate, Drain, Source 세 개의 핀을 사용
    * 오늘날의 IC는 전부 이걸 씀 MOSFET


* Vcc : collector 전원 +
* Vee : emitter 전원 - 
* Vdd : drain 전원 +
* Vss : source 전원 - 또는 접지

> 트랜지스터는 스위치??

* 저항 없이 연결 해놓으면 회로 탈 수도 있음. 입력 모드에서 이야기임 

* dts는 Board당 하나 SoC는 dtsi 하나 Borad는 include를 한다. 

* Interrupt (http://jake.dothome.co.kr/ic/)
    * SPI (Shared ...) : 프레임에서 인터럽트가 가는 방향을 설정할 수 있음. 우리가 대부분 쓰는거
        * 0~31은 각 CPU로 알아서 지들이 쓰고 그 위의 번호들을 Share
    * SGI : CPU마다 pin이 있음. CPU전용 외부 핀이 없음. Software generate 소프트웨어 인터럽트 처리를 위한 것...
    * PPI : CPU마다 pin이 있음. CPU전용 외부에서 쓸 수 있는 CPU별로 있는 거. SOC 설계자들이 쓰는거

* http://jake.dothome.co.kr/gpio-2/

* 핀컨트롤은 SoC 내부에서만 쓰기 떄문에 대부분 플랫폼 드라이버임.

* SoC

* irqdomain - http://jake.dothome.co.kr/interrupts-3/
    * 각 제조사의 인터럽트 컨트롤러에 고정 매핑 또는 프로그래머블 매핑 기능이 있는 경우가 많이 있다. 그리고 리눅스 인터럽트에 대해 매핑되기 전 실제 하드웨어 인터럽트 번호를 알아내기 위해 리버스 매핑(리눅스 irq -> hw irq) 기능을 필요하게 되었고 이를 구현하기 위해 다음과 같은 방법들을 고려하여 몇 가지의 구현 방법을 준비하였다
    * virtual irq 번호 이건 커널에서 사용하는 irq 번호, hwirq 이 번호는 외부에서 활용됨.

* 상위 Interrupt 컨트롤러와의 cascade 연동
    * chained 방식(빠른거 pci) - interrupt context, 
    * nested irq 방식(느린거 i2c, spi) - process context

* Generic Memory Mapped GPIO

## 실습 
* input/output 설정하는 reg가 set 형태의 reg가 있을 수 있고, 하나만 쓸 수 도있음

* 보통 5개의 레지스터가 있음. dat, set, clr, dirout, dirin.  set을 1로 하면 1일 때 출력이나 인풋이 감. clr가 1이면 0일 때 출력이나 인풋이 감'

* p0, p1이 있고

* dtc "dtsfile" -o "dtbfile -I dts -O dtb

* 크로스 컴파일 옵션
```
export PATH=/opt/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-linux-gnu/bin
export ARCH=arm64
export CROSS_COMPILE=aarch64-linux-gnu-
```

* qemu 옵션
```
    * dtb 적용 -dtb <FILENAME>.dtb 
    * dtb 떨굼 -machine virt,dumpdtb=virt_original.dtb

```

* dtc 명령어
    * dtb to dts : $ dtc -I dtb -O dts virt_default.dtb -o virt_default.dts
    * dts to dtb : $ dtc -I dts -O dtb virt.dts -o virt.dtb

* arm은 512개 핀을 쓸 수 있게 해놨음.
    * gpiochip504 ~ qemu가 만든거
    * 498 500이 우리가 만든거.

## 20180728
* gpio 사용하는 방법
    1. /sys/class/gpio 하위에 있는 파일 이용하는 건 user layer에서 너무 귀찮음
    2. character device로 만ㄷ르어서 사용하기 
        *  miscelleous?? misc 잡동사니 장치
        * misc_register로 만들든 major/minor 번호 관리하던 어쨰든 character device로 만들어서 사용
        * ioctl 사용
        * 4.8부터 유저에게 사용할 character 장치 만들어주고 함수 다 제공함.


### character device로 만들어서 제어하기
* 

* struct gpio_desc
    * label, name, FLAG
    * 이름은 이름이고, connection id의 이름


## 20180825
* word 단위 PC에서는 2바이트, arm에서는 4바이트
* tcp 장비들은 빅엔디안, cpu들은 리틀엔디안, network 오더 빅엔디안(hton, host to network. 포트번호 16비트 htons (short) 4바이트 htonl ())

http://jake.dothome.co.kr/i2c-1/
http://jake.dothome.co.kr/i2c-2/
http://jake.dothome.co.kr/i2c-3/

### drivers/i2c/busses/bcm2835
* algo : 이게 루틴
* quirks : io 제한 걸기

struct i2c_msg {
    __u16 addr; // 10bit 주소를 쓰는 장치가 있음
    __u16 flag; // 지금은 8개 나중을 위해서
}

데이터 시트가 없고 소스 분석하는건 어려움(리버스 엔지니어링...) 추측하는거임..

## i2c-gpio.c
adap->algo가 없으면 algo_data를 이용